/*
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.android.libraries.pcc.chronicle.api.operation

/**
 * An [Operation] is a [named][name] mapping from [inputType] to [outputType] via the result type:
 * [Action].
 *
 * Operations are used to apply conditional usage filters/redactions/truncations/etc.
 *
 * An operation is considered equal to another operation if and only if its [name], [inputType], and
 * [outputType] are equal. Thus, it is important that functionally-different operations have
 * different names or input/output types.
 */
abstract class Operation<A, B>(
  val name: String,
  val inputType: Class<out A & Any>,
  val outputType: Class<out B & Any>,
) : (A) -> Action<out B> {
  /**
   * Calculates an [Action] of type [B] from the input [value]. This is the body of the operation.
   */
  abstract override fun invoke(value: A): Action<out B>

  // Generated by intellij
  override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is Operation<*, *>) return false

    if (name != other.name) return false
    if (inputType != other.inputType) return false
    if (outputType != other.outputType) return false

    return true
  }

  // Generated by intellij
  override fun hashCode(): Int {
    var result = name.hashCode()
    result = 31 * result + inputType.hashCode()
    result = 31 * result + outputType.hashCode()
    return result
  }

  companion object {
    /**
     * Creates an [Operation] that can never return an [Action.Update], only omissions or throwing
     * [Actions][Action]. The [block] may return `null`, in which case the operation will cause
     * no-change.
     */
    inline fun <reified A> createNonUpdating(
      name: String,
      crossinline block: (value: A) -> Action<Nothing>?,
    ): Operation<A, Nothing> {
      return object :
        // TODO: KT-51188 - Remove cast once there is a better way.
        Operation<A, Nothing>(name, A::class.java as Class<A & Any>, Nothing::class.java) {
        override fun invoke(value: A): Action<out Nothing> {
          @Suppress("UNCHECKED_CAST") // It's a no-op when the cast occurs, so nothing is awry.
          return block(value) ?: Action.Update(value) as Action<out Nothing>
        }
      }
    }

    /** Creates an [Operation] mapping input values of type [A] to [Actions][Action] of type [A]. */
    inline fun <reified A> create(
      name: String,
      crossinline block: (value: A) -> Action<out A>,
    ): Operation<A, A> {
      return object :
        // TODO: KT-51188 - Remove cast once there is a better way.
        Operation<A, A>(name, A::class.java as Class<A & Any>, A::class.java as Class<A & Any>) {
        override fun invoke(value: A): Action<out A> = block(value)
      }
    }

    /**
     * Creates an [Operation] mapping input values of type [A] to [Actions][Action] of type [B].
     *
     * It's important to note that transform operations are not usually applicable to conditional
     * usage from policies, unless B is a subclass of A (example: input is nullable and output
     * should be non-null).
     */
    inline fun <reified A, reified B> createTransform(
      name: String,
      crossinline block: (value: A) -> Action<out B>,
    ): Operation<A, B> {
      return object :
        // TODO: KT-51188 - Remove cast once there is a better way.
        Operation<A, B>(name, A::class.java as Class<A & Any>, B::class.java as Class<B & Any>) {
        override fun invoke(value: A): Action<out B> = block(value)
      }
    }
  }
}
